<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:og="http://ogp.me/ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:schema="http://schema.org/" xmlns:sioc="http://rdfs.org/sioc/ns#" xmlns:sioct="http://rdfs.org/sioc/types#" xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" version="2.0" xml:base="https://drupal-coder.ru/">
  <channel>
    <title>svn</title>
    <link>https://drupal-coder.ru/</link>
    <description/>
    <language>ru</language>
    
    <item>
  <title>Пример работы над проектом в системе контроля версий (git)</title>
  <link>https://drupal-coder.ru/blog/primer-raboty-nad-proektom-v-sisteme-kontrola-versii-git</link>
  <description>
&lt;span&gt;Пример работы над проектом в системе контроля версий (git)&lt;/span&gt;

&lt;span&gt;&lt;a title="Просмотр профиля пользователя." href="https://drupal-coder.ru/user/64" lang="" about="https://drupal-coder.ru/user/64" typeof="schema:Person" property="schema:name" datatype="" xml:lang=""&gt;Алексей Зубенко&lt;/a&gt;&lt;/span&gt;

&lt;span&gt;вт, 05/22/2018 - 08:05&lt;/span&gt;
&lt;div id="field-language-display"&gt;&lt;div class="form-item js-form-item form-type-item js-form-type-item form-item- js-form-item- form-group"&gt;
      &lt;label class="control-label"&gt;Language&lt;/label&gt;
  
  
  Russian

  
  
  &lt;/div&gt;
&lt;/div&gt;
            &lt;div class="field field--name-body field--type-text-with-summary field--label-hidden field--item"&gt;&lt;p&gt;Возможности, которые привнесли в работу программиста системы контроля версий, подняли ее на совершенно иной уровень. И если поначалу, особенно на простых проектах, новый багаж необходимых для этого знаний и навыков несколько пугает — да что там говорить, в первое время заметно замедляет работу,— то со временем с переходом на более сложные задачи становится уже не просто необычным средством бэкапа, а одним из основных инструментов, сохраняющим огромное количество времени, нервов и, в конечном итоге, денег.&lt;/p&gt;

&lt;p&gt;И тут главное выбрать рабочий процесс, который бы максимально удовлетворял запросам компании. Об одном из таких шаблонов я бы хотел рассказать. Я сам познакомился с GIT сравнительно недавно, а вплотную использую его не более полугода, поэтому мое описание вряд ли будет претендовать на полноту. Однако, возможно, именно такое объяснение на пальцах поможет правильно понять необходимые основы.&lt;/p&gt;

&lt;p&gt;Цепочка применения изменений в нашем случае будет выглядеть как «Feature» -&gt; «Dev» -&gt; «Production». Между «dev» и «production» еще может возникать «stage», но это уже зависит от конкретных особенностей проекта, в том числе финансовых.&lt;/p&gt;

&lt;p&gt;То есть изменения, внесенные в проект разработчиком, переносятся на тестовый сайт, где происходит необходимое тестирование. После принятия решения о пригодности изменений они заливаются на stage, равный во всех отношениях «боевой» площадке и далее уже копируются на нее.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Как это выглядит на пальцах?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Программист на локальной машине создает новую ветку, в котрой он будет работать над поставленной задачей. И тут надо запомнить первую и одну из самых главных тонкостей - ветка создается только от актуальной основной («master») ветки.&lt;/p&gt;

&lt;p&gt;Почему именно так? Какими бы не были схожими ваши ветки, они все разные, причем иногда разные кардинально - начиная от прав доступа к файлам и заканчивая порой совершенно неопределимыми различиями, исток которых, по всей видимости, кроется чуть ли не в рознящихся контрольных суммах. Однако в конечном итоге любые изменения будут заливаться в основную ветку, на которой работает production. И стоит при создании новой ветки по невнимательности отнаследоваться от другой — и долгие часы разруливания конфликтов вам обеспечены.&lt;/p&gt;

&lt;p&gt;То есть что бы ни происходило в нашей голове, мы должны сделать следующие шаги:&lt;/p&gt;

&lt;p&gt;Переключаемся на основную ветку:&lt;/p&gt;

&lt;pre&gt;
git checkout master&lt;/pre&gt;

&lt;p&gt;Обновляем ее:&lt;/p&gt;

&lt;pre&gt;
git pull -p&lt;/pre&gt;

&lt;p&gt;В общих чертах pull состоит из двух компонентов: команды fetch, которая подтягивает изменения с удаленного репозитория, и команды merge, которая совмещает эти изменения с вашей локальной веткой.&lt;/p&gt;

&lt;p&gt;Параметр «-p» слабо документирован, однако очень приятен в работе. Формально он никак не относится к самой команде pull, потому вы вряд ли найдете упоминание о нем в ее описании. Однако он передается в fetch, что приводит к удалению всех локальных веток, которые ранее существовали, но были удалены из удаленного репозитория. По сути это избавляет вас от исторического мусора, который со временем начинает доставлять боль при выводе списка веток, не говоря уже о невозможности пользоваться атодополнением.&lt;/p&gt;

&lt;p&gt;Создаем feature-ветку&lt;/p&gt;

&lt;pre&gt;
git checkout -b [название-ветки]&lt;/pre&gt;

&lt;p&gt;Давайте договоримся, что далее будем ее назвать, например «task-name»&lt;/p&gt;

&lt;p&gt;Теперь можно работать в свое удовольствие, ну или ради чего вы там все это затеяли.&lt;/p&gt;

&lt;p&gt;Интересное начинается позже. Пока мы пишем код, тем же занимаются и наши коллеги. Да, порой это трудно признать, но помимо вас тоже есть люди, которые работают. И в основную ветку начинают заливаться изменения, которые все далее и далее отдаляют ее от вашей. Простейший алгоритм слияния изменений, который используется гитом (включение или кода между соседними одинаковыми строками) уже не сработает - структура master изменилась. То есть если мы закончим нашу работу, тщательно протестируем все локально и начнем сливать все в master, то увидим кучу незнакомого кода, который, как кажется, специально написан в самых неподходящих местах, чтобы испортить нашу жизнь.&lt;/p&gt;

&lt;p&gt;Как избежать этого? Если честно, то, к сожалению, практически никак. Рано или поздно нам придется исправлять возникающие конфликты. Вопрос — когда и сколько сразу. Здесь есть два подхода.&lt;/p&gt;

&lt;p&gt;Если коротко, то первый состоит в том, чтобы сделать это в самом конце, когда будем сливать изменения в вышестоящую ветку (в нашем случае это ветка, соответствующая stage-сайту). У этого метода есть свои преимущества, но все равно будет много боли, причем сразу. При этом психологически будет сложнее, потому что в уме вы свою работу уже сделали и хочется поскорее про нее забыть, как про страшный сон.&lt;/p&gt;

&lt;p&gt;Вторая состоит в использовании rebase. Что это за зверь такой, надо сказать, я не сразу понял. Каждый раз, когда я в чтении мануалов доходил до этого момента, глаза застилала пелена и с мыслью о том, что уж это-то мне точно не пригодится еще пару лет, я шел прокрастинировать дальше.&lt;/p&gt;

&lt;p&gt;На самом деле все достаточно просто. Rebase - это процесс подтягивания изменений с основной ветки (вообще, с любой, но мы сейчас не об этом) в вашу. Иначе говоря, каждый божий день, перед работой и перед отправкой изменений на удаленный репозиторий вы заливаете все последние изменения с той ветки, от которой отнаследовались при создании вашей (конечно же, от master) и исправляете небольшую порцию конфликтов, если они есть.&lt;/p&gt;

&lt;p&gt;Далее мы предполагаем, что вы находитесь на своей feature-ветке.&lt;/p&gt;

&lt;p&gt;Ребейз можно делать на локальную ветку и тогда это будет выглядеть так:&lt;/p&gt;

&lt;pre&gt;
git rebase master&lt;/pre&gt;

&lt;p&gt;Но на самом деле это не сильно удобно, потому что локальная ветка имеет все шансы быть неактуальной (а регулярно переключаться на нее и делать git pull просто так на всякий случай - занятие, как бы это сказать, из области психиатрии). Поэтому мы сделаем иначе:&lt;/p&gt;

&lt;pre&gt;
git pull -r origin master&lt;/pre&gt;

&lt;p&gt;То есть все примерно то же самое, но мы ребейзим не на локальный, а на удаленный, оригинальный master, как бы далеко он не ушел от локального.&lt;/p&gt;

&lt;p&gt;В процессе ребейза все ваши коммиты последовательно сливаются в master.&lt;/p&gt;

&lt;p&gt;При возникновении конфликтов, о чем git нам непременно сообщит кучей гневных сообщений, мы их правим (некоторые подробности чуть ниже по тексту), добавляем исправленные файлы:&lt;/p&gt;

&lt;pre&gt;
git add -u&lt;/pre&gt;

&lt;p&gt;и продолжаем процесс ребейза:&lt;/p&gt;

&lt;pre&gt;
git rebase --continue&lt;/pre&gt;

&lt;p&gt;Исправление текущего конфликта в редких случаях можно пропустить:&lt;/p&gt;

&lt;pre&gt;
git rebase --skip&lt;/pre&gt;

&lt;p&gt;Или полностью откатить весь процесс:&lt;/p&gt;

&lt;pre&gt;
git rebase --abort&lt;/pre&gt;

&lt;p&gt;Небольшая неожиданность возникнет при попытке залить отребейзенную ветку на удаленный репозиторий. Обычный git push уже не сработает, потому что с точки зрения репозитория ваша локальная и удаленная ветки расходятся и не могут быть слиты, что совершенно правильно.&lt;/p&gt;

&lt;p&gt;Поэтому мы будем вынуждены отправить нашу измененную ветку насильно:&lt;/p&gt;

&lt;pre&gt;
git push -f&lt;/pre&gt;

&lt;p&gt;И здесь кроется небольшой недостаток метода, так как история изменений при этом теряется, и если вы накосячили с ребейзом, исправить содеянное будет уже не так легко. Поэтому если изменений много и они существенные, то перед началом ребейза не лишним будет подстраховаться и сделать копию ветки:&lt;/p&gt;

&lt;pre&gt;
git checkout -b task-name-backup&lt;/pre&gt;

&lt;p&gt;И не забудьте переключиться назад перед ребейзом и дальнейшей работой:&lt;/p&gt;

&lt;pre&gt;
git checkout task-name&lt;/pre&gt;

&lt;p&gt;И обязательно, в самом конце, когда все и везде протестировано и уже есть добро на перенос вашей работы на рабочий сайт, снова сделать ребейз, чтобы merge в master не вызвал неожиданностей.&lt;/p&gt;

&lt;p&gt;Но это чуть позже. Сейчас мы уверены, что все хорошо и можно отдавать работу на тестирование. Мы делаем мерж в ветку, на которой работает дев-сайт. Могу поспорить, что она так и называется — dev.&lt;/p&gt;

&lt;p&gt;Ребейзим ветку на master (не обязательно, но не помешает, к тому же должно уменьшить расхождение между dev и master):&lt;/p&gt;

&lt;pre&gt;
git pull -r origin master&lt;/pre&gt;

&lt;p&gt;Переключаемся на dev и актуализируем ее:&lt;/p&gt;

&lt;pre&gt;
git checkout dev
git pull&lt;/pre&gt;

&lt;p&gt;Внимание - короткая дорога:&lt;/p&gt;

&lt;pre&gt;
git checkout -B dev origin/dev&lt;/pre&gt;

&lt;p&gt;Так мы одномоментно переключимся и сбросим ветку до состояния origin - меньше телодвижений всяко приятней.&lt;/p&gt;

&lt;p&gt;Сливаем ветки:&lt;/p&gt;

&lt;pre&gt;
git merge task-name&lt;/pre&gt;

&lt;p&gt;С большой степенью вероятности получаем конфликты, количество которых зависит от нашей кармы.&lt;/p&gt;

&lt;p&gt;Смотрим список того, что конфликтует:&lt;/p&gt;

&lt;pre&gt;
git status&lt;/pre&gt;

&lt;p&gt;Проводим некоторое время над разрешением конфликтов. Все конфликты git отмечает примерно следующим образом:&lt;/p&gt;

&lt;pre&gt;
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
    &lt;link type="text/css" rel="stylesheet" media="all" href="style.css" /&gt;
=======
    &lt;!-- no style --&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; task-name&lt;/pre&gt;

&lt;p&gt;Собственно, по этим многочисленным угловым скобкам и можно провести поиск в каждом конфликтующем файле.&lt;/p&gt;

&lt;p&gt;В принципе, этой разметки и должной степени сосредоточенности должно хватить на разруливание всего этого ужаса. В особо сложных случаях можно воспользоваться каким-нибудь инструментом по разрешению merge-конфликтов, которые, в частности, есть почти у каждого серьезного IDE. Хотя это по большей части даст вам лишь более человечный интерфейс.&lt;/p&gt;

&lt;p&gt;Учтите, неизвестный вам код в большинстве случаев не нужно удалять - его потом другие люди искать будут.&lt;/p&gt;

&lt;p&gt;Как и вслучае с ребейзом, процесс мержа можно откатить:&lt;/p&gt;

&lt;pre&gt;
git merge --abort&lt;/pre&gt;

&lt;p&gt;Когда все конфликты разрешены, а соответствующее им обрамление удалено, делаем git add исправленных файлов. Впрочем, делаем в большинстве случаев добавление всех измененных файлов:&lt;/p&gt;

&lt;pre&gt;
git add -u&lt;/pre&gt;

&lt;p&gt;Создаем коммит с указанием того, что решали конфликты слияния (далее дева этот коммит не пойдет и карму нам не испортит)&lt;/p&gt;

&lt;pre&gt;
git commit -m "Task-name - fixing merge conflicts"&lt;/pre&gt;

&lt;p&gt;И заливаем все это на удаленный репозиторий.&lt;/p&gt;

&lt;pre&gt;
git push&lt;/pre&gt;

&lt;p&gt;Далее специально обученные люди решают, насколько ваше творение соответствует общественным ожиданиям, однако рано или поздно будет принято решение мержить ветку в production.&lt;/p&gt;

&lt;p&gt;И тут еще одна тонкость. Я бы сказал - жирность: dev и master сайты находятся в этой цепочке не последовательно, а параллельно. Иными словами, мы не переносим изменения из dev в master. Feature-ветка мержится в master напрямую. Во многом именно поэтому мы наследуемся именно от мастера и регулярно на этот мастер ребейзим.&lt;/p&gt;

&lt;p&gt;Конечно, такой процесс неизбежно приведет к росту расхождений между рабочим и тестовым сайтом, но по мере необходимости последний можно актуализировать, попросту делая push --force мастера в дев.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Какие могут быть проблемы и как их избежать&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Никак. Если проект большой, то так или иначе вы будете сталкиваться с необходимостью при решении конфликтов разбираться не только в своем, но и в чужом коде. И здесь важно не только обеспечить работоспособность своего функционала, но и не сломать чужой. Для этого нужно при необходимости тесно контактировать с другими разработчиками и никогда не действовать по принципу «что это тут за лишний код понапоявлялся... скопирую-ка я в этой файл содержимое своей ветки». Иначе отдельный котел вам будет обеспечен, и хорошо, если в иной жизни, а не в этой, причем вечером и в пятницу.&lt;/p&gt;

&lt;p&gt;Очень хорошо, если ваши коллеги руководствуются теми же принципами. В таком случае вы будете избавлены от неожиданностей, когда заказчик начинает обвинять вас в поломке, при этом ни он и ни вы до поры до времени даже не подозреваете, что порядочный кусок кода был удален нерадивым сотрудником.&lt;/p&gt;

&lt;p&gt;Ну и, безусловно, основная доля серьезных проблем возникает, если вы или кто-то из сотрудников нарушает основные правила работы с репозиторием - начинают ветку не от master или даже работают непосредственно в master.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Итого&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В любом деле понимание приходит по большей части с опытом, поэтому даже если вы освоили теорию и красиво рисуете схемы ветвления на бумаге, это не избавит вас от необходимости хождения по граблям. Это нормально. Главное - делать правильные выводы из каждого такого случая.&lt;/p&gt;&lt;/div&gt;
      
      &lt;div class="field field--name-field-kategoria field--type-entity-reference field--label-hidden field--items"&gt;
              &lt;div class="field--item category-tag"&gt;&lt;a href="https://drupal-coder.ru/blog/git" hreflang="ru"&gt;git&lt;/a&gt;&lt;/div&gt;
              &lt;div class="field--item category-tag"&gt;&lt;a href="https://drupal-coder.ru/blog/svn" hreflang="ru"&gt;svn&lt;/a&gt;&lt;/div&gt;
          &lt;/div&gt;
  &lt;section&gt;&lt;div class="comment-form-wrapper"&gt;
      &lt;h2 class="block-form-title"&gt;Добавить комментарий&lt;/h2&gt;
      &lt;drupal-render-placeholder callback="comment.lazy_builders:renderForm" arguments="0=node&amp;1=145&amp;2=comment&amp;3=comment" token="a33qdQaTba_r0l1vv_FwBZIgC6oqt3O6UNjiRBrveEo"&gt;&lt;/drupal-render-placeholder&gt;&lt;/div&gt; 
  
&lt;/section&gt;</description>
  <pubDate>Tue, 22 May 2018 08:05:27 +0000</pubDate>
    <dc:creator>Алексей Зубенко</dc:creator>
    <guid isPermaLink="false">145 at https://drupal-coder.ru</guid>
    </item>

  </channel>
</rss>
